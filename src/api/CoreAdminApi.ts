/**
 * Selfbits API V2
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class CoreAdminApi {
    public configuration: Configuration = new Configuration();
    public defaultHeaders: Headers = new Headers();
	public sbClientId: string = null;
	public sbClientSecret: string = null;

    constructor(protected http: Http, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
			this.sbClientId = this.configuration.sbClientId;
			this.sbClientSecret = this.configuration.sbClientSecret;
            this.defaultHeaders = new Headers({'Authorization': this.configuration.apiKey});
        }
    }

    /**
     * Execute a REST request to a deployed REST API
     * Execute a REST request to a deployed REST API
     * @param stage The stage identifier
     * @param resource The resource path
     */
    public _delete(stage: string, resource: string, extraHttpRequestParams?: any): Observable<models.RestEndpointExecutionResponse> {
        return this._deleteWithHttpInfo(stage, resource, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create multiple new actions
     * Create multiple new actions
     * @param actions Multiple actions
     */
    public actionsCreateMany(actions?: models.NewActionArray, extraHttpRequestParams?: any): Observable<models.ActionArray> {
        return this.actionsCreateManyWithHttpInfo(actions, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new action
     * Create new action
     * @param action Your new action
     */
    public actionsCreateOne(action?: models.NewAction, extraHttpRequestParams?: any): Observable<models.Action> {
        return this.actionsCreateOneWithHttpInfo(action, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing actions
     * Bulk delete existing actions
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public actionsDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.actionsDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing action
     * delete existing action
     * @param actionId The action identifier
     */
    public actionsDeleteOne(actionId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.actionsDeleteOneWithHttpInfo(actionId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Execute action.
     * Execute action. If the action code throws errors, they are caught and information is provided in the payload with status code 200.
     * @param actionId The action identifier
     * @param payload Execution payload
     */
    public actionsExecuteOne(actionId: string, payload?: models.ActionExecutionRequestPayload, extraHttpRequestParams?: any): Observable<models.ActionExecutionResponse> {
        return this.actionsExecuteOneWithHttpInfo(actionId, payload, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns actions
     * Returns actions
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public actionsQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.ActionPage> {
        return this.actionsQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing action
     * Get one existing action
     * @param actionId The action identifier
     */
    public actionsReadOne(actionId: string, extraHttpRequestParams?: any): Observable<models.Action> {
        return this.actionsReadOneWithHttpInfo(actionId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk update existing actions
     * Bulk update existing actions
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param actionBulkUpdate Use filter to find the actions and do a bulk update
     */
    public actionsUpdateMany(filter: string, actionBulkUpdate: models.ActionBulkUpdate, extraHttpRequestParams?: any): Observable<models.BulkUpdateResponse> {
        return this.actionsUpdateManyWithHttpInfo(filter, actionBulkUpdate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing action
     * update existing action
     * @param actionId The user identifier
     * @param updatedAction updated action
     */
    public actionsUpdateOne(actionId: string, updatedAction: models.ActionUpdate, extraHttpRequestParams?: any): Observable<models.Action> {
        return this.actionsUpdateOneWithHttpInfo(actionId, updatedAction, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * change user password globally
     * change user password globally
     * @param userId The user identifier or me
     * @param adminChangePasswordRequest change password request
     */
    public changeUserPasswordAllOrganizations(userId: string, adminChangePasswordRequest: models.AdminChangePasswordRequest, extraHttpRequestParams?: any): Observable<models.AdminChangePasswordResponse> {
        return this.changeUserPasswordAllOrganizationsWithHttpInfo(userId, adminChangePasswordRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * change user password for one organization
     * change user password for one organization
     * @param userId The user identifier or me
     * @param organizationId The user identifier or me
     * @param adminChangePasswordRequest change password request
     */
    public changeUserPasswordByOrganization(userId: string, organizationId: string, adminChangePasswordRequest: models.AdminChangePasswordRequest, extraHttpRequestParams?: any): Observable<models.AdminChangePasswordResponse> {
        return this.changeUserPasswordByOrganizationWithHttpInfo(userId, organizationId, adminChangePasswordRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create multiple new clients
     * Create multiple new clients
     * @param clients Multiple clients
     */
    public clientsCreateMany(clients?: models.NewClientArray, extraHttpRequestParams?: any): Observable<models.ClientArray> {
        return this.clientsCreateManyWithHttpInfo(clients, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new client
     * Create new client
     * @param client Your new client
     */
    public clientsCreateOne(client?: models.NewClient, extraHttpRequestParams?: any): Observable<models.Client> {
        return this.clientsCreateOneWithHttpInfo(client, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing clients
     * Bulk delete existing clients
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public clientsDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.clientsDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing client
     * delete existing client
     * @param clientId The client identifier
     */
    public clientsDeleteOne(clientId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.clientsDeleteOneWithHttpInfo(clientId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns clients
     * Returns clients
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public clientsQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.ClientPage> {
        return this.clientsQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing client
     * Get one existing client
     * @param clientId The client identifier
     */
    public clientsReadOne(clientId: string, extraHttpRequestParams?: any): Observable<models.Client> {
        return this.clientsReadOneWithHttpInfo(clientId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk update existing clients
     * Bulk update existing clients
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param clientBulkUpdate Use filter to find the clients and do a bulk update
     */
    public clientsUpdateMany(filter: string, clientBulkUpdate: models.ClientBulkUpdate, extraHttpRequestParams?: any): Observable<models.BulkUpdateResponse> {
        return this.clientsUpdateManyWithHttpInfo(filter, clientBulkUpdate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing client
     * update existing client
     * @param clientId The user identifier
     * @param updatedClient updated client
     */
    public clientsUpdateOne(clientId: string, updatedClient: models.ClientUpdate, extraHttpRequestParams?: any): Observable<models.Client> {
        return this.clientsUpdateOneWithHttpInfo(clientId, updatedClient, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing consumers
     * Bulk delete existing consumers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public consumersDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.consumersDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing consumer
     * delete existing consumer
     * @param consumerId The consumer identifier
     */
    public consumersDeleteOne(consumerId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.consumersDeleteOneWithHttpInfo(consumerId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns consumers
     * Returns consumers
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public consumersQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.ConsumerPage> {
        return this.consumersQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing consumer
     * Get one existing consumer
     * @param consumerId The consumer identifier
     */
    public consumersReadOne(consumerId: string, extraHttpRequestParams?: any): Observable<models.Consumer> {
        return this.consumersReadOneWithHttpInfo(consumerId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk update existing consumers
     * Bulk update existing consumers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param consumerBulkUpdate Use filter to find the consumers and do a bulk update
     */
    public consumersUpdateMany(filter: string, consumerBulkUpdate: models.ConsumerBulkUpdate, extraHttpRequestParams?: any): Observable<models.BulkUpdateResponse> {
        return this.consumersUpdateManyWithHttpInfo(filter, consumerBulkUpdate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing consumer
     * update existing consumer
     * @param consumerId The user identifier
     * @param updatedConsumer updated consumer
     */
    public consumersUpdateOne(consumerId: string, updatedConsumer: models.ConsumerUpdate, extraHttpRequestParams?: any): Observable<models.Consumer> {
        return this.consumersUpdateOneWithHttpInfo(consumerId, updatedConsumer, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing devices
     * Bulk delete existing devices
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public devicesDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.devicesDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing device
     * delete existing device
     * @param deviceId The device identifier
     */
    public devicesDeleteOne(deviceId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.devicesDeleteOneWithHttpInfo(deviceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns devices
     * Returns devices
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public devicesQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.DevicePage> {
        return this.devicesQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing device
     * Get one existing device
     * @param deviceId The device identifier
     */
    public devicesReadOne(deviceId: string, extraHttpRequestParams?: any): Observable<models.Device> {
        return this.devicesReadOneWithHttpInfo(deviceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create multiple new directories
     * Create multiple new directories
     * @param directories Multiple directories
     */
    public directoriesCreateMany(directories?: models.NewDirectoryArray, extraHttpRequestParams?: any): Observable<models.DirectoryArray> {
        return this.directoriesCreateManyWithHttpInfo(directories, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new directory
     * Create new directory
     * @param directory Your new directory
     */
    public directoriesCreateOne(directory?: models.NewDirectory, extraHttpRequestParams?: any): Observable<models.Directory> {
        return this.directoriesCreateOneWithHttpInfo(directory, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing directories
     * Bulk delete existing directories
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public directoriesDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.directoriesDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing directory
     * delete existing directory
     * @param directoryId The directory identifier
     */
    public directoriesDeleteOne(directoryId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.directoriesDeleteOneWithHttpInfo(directoryId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns directories
     * Returns directories
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public directoriesQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.DirectoryPage> {
        return this.directoriesQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing directory
     * Get one existing directory
     * @param directoryId The directory identifier
     */
    public directoriesReadOne(directoryId: string, extraHttpRequestParams?: any): Observable<models.Directory> {
        return this.directoriesReadOneWithHttpInfo(directoryId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk update existing users
     * Bulk update existing users
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param directoryBulkUpdate Use filter to find the directories and do a bulk update
     */
    public directoriesUpdateMany(filter: string, directoryBulkUpdate: models.DirectoryBulkUpdate, extraHttpRequestParams?: any): Observable<models.BulkUpdateResponse> {
        return this.directoriesUpdateManyWithHttpInfo(filter, directoryBulkUpdate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing directory
     * update existing directory
     * @param directoryId The user identifier
     * @param updatedDirectory updated directory
     */
    public directoriesUpdateOne(directoryId: string, updatedDirectory: models.DirectoryUpdate, extraHttpRequestParams?: any): Observable<models.Directory> {
        return this.directoriesUpdateOneWithHttpInfo(directoryId, updatedDirectory, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create multiple new endpoints
     * Create multiple new endpoints
     * @param endpoints Multiple endpoints
     */
    public endpointsCreateMany(endpoints?: models.NewEndpointArray, extraHttpRequestParams?: any): Observable<models.EndpointArray> {
        return this.endpointsCreateManyWithHttpInfo(endpoints, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new endpoint
     * Create new endpoint
     * @param endpoint Your new endpoint
     */
    public endpointsCreateOne(endpoint?: models.NewEndpoint, extraHttpRequestParams?: any): Observable<models.Endpoint> {
        return this.endpointsCreateOneWithHttpInfo(endpoint, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing endpoints
     * Bulk delete existing endpoints
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public endpointsDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.endpointsDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing endpoint
     * delete existing endpoint
     * @param endpointId The endpoint identifier
     */
    public endpointsDeleteOne(endpointId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.endpointsDeleteOneWithHttpInfo(endpointId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Deploy endpoint to stage
     * Deploy endpoint to stage
     * @param endpointId The endpoint identifier
     * @param stage The stage identifier
     */
    public endpointsDeployOneToStage(endpointId: string, stage: string, extraHttpRequestParams?: any): Observable<models.RestEndpoint> {
        return this.endpointsDeployOneToStageWithHttpInfo(endpointId, stage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns endpoints
     * Returns endpoints
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public endpointsQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.EndpointPage> {
        return this.endpointsQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing endpoint
     * Get one existing endpoint
     * @param endpointId The endpoint identifier
     */
    public endpointsReadOne(endpointId: string, extraHttpRequestParams?: any): Observable<models.Endpoint> {
        return this.endpointsReadOneWithHttpInfo(endpointId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk update existing users
     * Bulk update existing users
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param endpointBulkUpdate Use filter to find the endpoints and do a bulk update
     */
    public endpointsUpdateMany(filter: string, endpointBulkUpdate: models.EndpointBulkUpdate, extraHttpRequestParams?: any): Observable<models.BulkUpdateResponse> {
        return this.endpointsUpdateManyWithHttpInfo(filter, endpointBulkUpdate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing endpoint
     * update existing endpoint
     * @param endpointId The user identifier
     * @param updatedEndpoint updated endpoint
     */
    public endpointsUpdateOne(endpointId: string, updatedEndpoint: models.EndpointUpdate, extraHttpRequestParams?: any): Observable<models.Endpoint> {
        return this.endpointsUpdateOneWithHttpInfo(endpointId, updatedEndpoint, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Execute a REST request to a deployed REST API
     * Execute a REST request to a deployed REST API
     * @param stage The stage identifier
     * @param resource The resource path
     */
    public get(stage: string, resource: string, extraHttpRequestParams?: any): Observable<models.RestEndpointExecutionResponse> {
        return this.getWithHttpInfo(stage, resource, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing invites
     * Bulk delete existing invites
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public invitesDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.invitesDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing invite
     * delete existing invite
     * @param inviteId The invite identifier
     */
    public invitesDeleteOne(inviteId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.invitesDeleteOneWithHttpInfo(inviteId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns invites
     * Returns invites
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public invitesQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.OrganizationInvitePage> {
        return this.invitesQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing invite
     * Get one existing invite
     * @param inviteId The invite identifier
     */
    public invitesReadOne(inviteId: string, extraHttpRequestParams?: any): Observable<models.OrganizationInvite> {
        return this.invitesReadOneWithHttpInfo(inviteId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new mailServer
     * Create new mailServer
     * @param mailServer Your new mailServer
     */
    public mailserversCreateOne(mailServer?: models.NewMailServer, extraHttpRequestParams?: any): Observable<models.MailServer> {
        return this.mailserversCreateOneWithHttpInfo(mailServer, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing mailservers
     * Bulk delete existing mailservers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public mailserversDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.mailserversDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing mailServer
     * delete existing mailServer
     * @param mailServerId The mailServer identifier
     */
    public mailserversDeleteOne(mailServerId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.mailserversDeleteOneWithHttpInfo(mailServerId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Disable the push service.
     * Disable the push service.
     * @param mailServerId The mailServer identifier
     */
    public mailserversDisableOne(mailServerId: string, extraHttpRequestParams?: any): Observable<models.MailServer> {
        return this.mailserversDisableOneWithHttpInfo(mailServerId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Enable the push service.
     * Enable the push service.
     * @param mailServerId The mailServer identifier
     */
    public mailserversEnableOne(mailServerId: string, extraHttpRequestParams?: any): Observable<models.MailServer> {
        return this.mailserversEnableOneWithHttpInfo(mailServerId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns mail servers
     * Returns mail servers
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public mailserversQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.MailServerPage> {
        return this.mailserversQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing mailServer
     * Get one existing mailServer
     * @param mailServerId The mailServer identifier
     */
    public mailserversReadOne(mailServerId: string, extraHttpRequestParams?: any): Observable<models.MailServer> {
        return this.mailserversReadOneWithHttpInfo(mailServerId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing mailServer
     * update existing mailServer
     * @param mailServerId The user identifier
     * @param updatedMailServer updated mailServer
     */
    public mailserversUpdateOne(mailServerId: string, updatedMailServer: models.MailServerUpdate, extraHttpRequestParams?: any): Observable<models.MailServer> {
        return this.mailserversUpdateOneWithHttpInfo(mailServerId, updatedMailServer, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create multiple new organizations
     * Create multiple new organizations
     * @param organizations Multiple organizations
     */
    public organizationsCreateMany(organizations?: models.NewOrganizationArray, extraHttpRequestParams?: any): Observable<models.OrganizationArray> {
        return this.organizationsCreateManyWithHttpInfo(organizations, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new organization
     * Create new organization
     * @param organization Your new organization
     */
    public organizationsCreateOne(organization?: models.NewOrganization, extraHttpRequestParams?: any): Observable<models.Organization> {
        return this.organizationsCreateOneWithHttpInfo(organization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing organizations
     * Bulk delete existing organizations
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public organizationsDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.organizationsDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing organization
     * delete existing organization
     * @param organizationId The organization identifier
     */
    public organizationsDeleteOne(organizationId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.organizationsDeleteOneWithHttpInfo(organizationId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns organizations
     * Returns organizations
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;isPublic\&quot;: \&quot;true\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     * @param _public Fixed filter for public organizations
     */
    public organizationsQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, _public?: boolean, extraHttpRequestParams?: any): Observable<models.OrganizationPage> {
        return this.organizationsQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, _public, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing organization
     * Get one existing organization
     * @param organizationId The organization identifier
     */
    public organizationsReadOne(organizationId: string, extraHttpRequestParams?: any): Observable<models.Organization> {
        return this.organizationsReadOneWithHttpInfo(organizationId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk update existing organizations
     * Bulk update existing organizations
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param organizationBulkUpdate Use filter to find the organizations and do a bulk update
     */
    public organizationsUpdateMany(filter: string, organizationBulkUpdate: models.OrganizationBulkUpdate, extraHttpRequestParams?: any): Observable<models.BulkUpdateResponse> {
        return this.organizationsUpdateManyWithHttpInfo(filter, organizationBulkUpdate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing organization
     * update existing organization
     * @param organizationId The user identifier
     * @param updatedOrganization updated organization
     */
    public organizationsUpdateOne(organizationId: string, updatedOrganization: models.OrganizationUpdate, extraHttpRequestParams?: any): Observable<models.Organization> {
        return this.organizationsUpdateOneWithHttpInfo(organizationId, updatedOrganization, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Execute a REST request to a deployed REST API
     * Execute a REST request to a deployed REST API
     * @param stage The stage identifier
     * @param resource The resource path
     * @param payload Execution payload
     */
    public post(stage: string, resource: string, payload?: models.RestEndpointExecutionRequestPayload, extraHttpRequestParams?: any): Observable<models.RestEndpointExecutionResponse> {
        return this.postWithHttpInfo(stage, resource, payload, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create multiple new providers
     * Create multiple new providers
     * @param providers Multiple providers
     */
    public providersCreateMany(providers?: models.NewProviderArray, extraHttpRequestParams?: any): Observable<models.ProviderArray> {
        return this.providersCreateManyWithHttpInfo(providers, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new provider
     * Create new provider
     * @param provider Your new provider
     */
    public providersCreateOne(provider?: models.NewProvider, extraHttpRequestParams?: any): Observable<models.Provider> {
        return this.providersCreateOneWithHttpInfo(provider, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing providers
     * Bulk delete existing providers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public providersDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.providersDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing provider
     * delete existing provider
     * @param providerId The provider identifier
     */
    public providersDeleteOne(providerId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.providersDeleteOneWithHttpInfo(providerId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns providers
     * Returns providers
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public providersQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.ProviderPage> {
        return this.providersQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing provider
     * Get one existing provider
     * @param providerId The provider identifier
     */
    public providersReadOne(providerId: string, extraHttpRequestParams?: any): Observable<models.Provider> {
        return this.providersReadOneWithHttpInfo(providerId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk update existing providers
     * Bulk update existing providers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param providerBulkUpdate Use filter to find the providers and do a bulk update
     */
    public providersUpdateMany(filter: string, providerBulkUpdate: models.ProviderBulkUpdate, extraHttpRequestParams?: any): Observable<models.BulkUpdateResponse> {
        return this.providersUpdateManyWithHttpInfo(filter, providerBulkUpdate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing provider
     * update existing provider
     * @param providerId The user identifier
     * @param updatedProvider updated provider
     */
    public providersUpdateOne(providerId: string, updatedProvider: models.ProviderUpdate, extraHttpRequestParams?: any): Observable<models.Provider> {
        return this.providersUpdateOneWithHttpInfo(providerId, updatedProvider, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new pushService
     * Create new pushService
     * @param pushService Your new pushService
     */
    public pushservicesCreateOne(pushService?: models.NewPushService, extraHttpRequestParams?: any): Observable<models.PushService> {
        return this.pushservicesCreateOneWithHttpInfo(pushService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing pushservices
     * Bulk delete existing pushservices
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public pushservicesDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.pushservicesDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing pushService
     * delete existing pushService
     * @param pushServiceId The pushService identifier
     */
    public pushservicesDeleteOne(pushServiceId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.pushservicesDeleteOneWithHttpInfo(pushServiceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Disable the push service.
     * Disable the push service.
     * @param pushServiceId The pushService identifier
     */
    public pushservicesDisableOne(pushServiceId: string, extraHttpRequestParams?: any): Observable<models.PushService> {
        return this.pushservicesDisableOneWithHttpInfo(pushServiceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Enable the push service.
     * Enable the push service.
     * @param pushServiceId The pushService identifier
     */
    public pushservicesEnableOne(pushServiceId: string, extraHttpRequestParams?: any): Observable<models.PushService> {
        return this.pushservicesEnableOneWithHttpInfo(pushServiceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns pushservices
     * Returns pushservices
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public pushservicesQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.PushServicePage> {
        return this.pushservicesQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing pushService
     * Get one existing pushService
     * @param pushServiceId The pushService identifier
     */
    public pushservicesReadOne(pushServiceId: string, extraHttpRequestParams?: any): Observable<models.PushService> {
        return this.pushservicesReadOneWithHttpInfo(pushServiceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing pushService
     * update existing pushService
     * @param pushServiceId The user identifier
     * @param updatedPushService updated pushService
     */
    public pushservicesUpdateOne(pushServiceId: string, updatedPushService: models.PushServiceUpdate, extraHttpRequestParams?: any): Observable<models.PushService> {
        return this.pushservicesUpdateOneWithHttpInfo(pushServiceId, updatedPushService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Execute a REST request to a deployed REST API
     * Execute a REST request to a deployed REST API
     * @param stage The stage identifier
     * @param resource The resource path
     * @param payload Execution payload
     */
    public put(stage: string, resource: string, payload?: models.RestEndpointExecutionRequestPayload, extraHttpRequestParams?: any): Observable<models.RestEndpointExecutionResponse> {
        return this.putWithHttpInfo(stage, resource, payload, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create multiple new roles
     * Create multiple new roles
     * @param roles Multiple roles
     */
    public rolesCreateMany(roles?: models.NewRoleArray, extraHttpRequestParams?: any): Observable<models.RoleArray> {
        return this.rolesCreateManyWithHttpInfo(roles, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new role
     * Create new role
     * @param role Your new role
     */
    public rolesCreateOne(role?: models.NewRole, extraHttpRequestParams?: any): Observable<models.Role> {
        return this.rolesCreateOneWithHttpInfo(role, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing roles
     * Bulk delete existing roles
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public rolesDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.rolesDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing role
     * delete existing role
     * @param roleId The role identifier
     */
    public rolesDeleteOne(roleId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.rolesDeleteOneWithHttpInfo(roleId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns roles
     * Returns roles
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public rolesQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.RolePage> {
        return this.rolesQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing role
     * Get one existing role
     * @param roleId The role identifier
     */
    public rolesReadOne(roleId: string, extraHttpRequestParams?: any): Observable<models.Role> {
        return this.rolesReadOneWithHttpInfo(roleId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk update existing roles
     * Bulk update existing roles
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param roleBulkUpdate Use filter to find the roles and do a bulk update
     */
    public rolesUpdateMany(filter: string, roleBulkUpdate: models.RoleBulkUpdate, extraHttpRequestParams?: any): Observable<models.BulkUpdateResponse> {
        return this.rolesUpdateManyWithHttpInfo(filter, roleBulkUpdate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing role
     * update existing role
     * @param roleId The user identifier
     * @param updatedRole updated role
     */
    public rolesUpdateOne(roleId: string, updatedRole: models.RoleUpdate, extraHttpRequestParams?: any): Observable<models.Role> {
        return this.rolesUpdateOneWithHttpInfo(roleId, updatedRole, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create new smsService
     * Create new smsService
     * @param smsService Your new smsService
     */
    public smsServiceCreateOne(smsService?: models.NewSmsService, extraHttpRequestParams?: any): Observable<models.SmsService> {
        return this.smsServiceCreateOneWithHttpInfo(smsService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk delete existing sms
     * Bulk delete existing sms
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public smsServiceDeleteMany(filter: string, extraHttpRequestParams?: any): Observable<models.BulkDeleteResponse> {
        return this.smsServiceDeleteManyWithHttpInfo(filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing smsService
     * delete existing smsService
     * @param smsServiceId The smsService identifier
     */
    public smsServiceDeleteOne(smsServiceId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.smsServiceDeleteOneWithHttpInfo(smsServiceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Disable the sms service.
     * Disable the sms service.
     * @param smsServiceId The smsService identifier
     */
    public smsServiceDisableOne(smsServiceId: string, extraHttpRequestParams?: any): Observable<models.SmsService> {
        return this.smsServiceDisableOneWithHttpInfo(smsServiceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Enable the sms service.
     * Enable the sms service.
     * @param smsServiceId The smsService identifier
     */
    public smsServiceEnableOne(smsServiceId: string, extraHttpRequestParams?: any): Observable<models.SmsService> {
        return this.smsServiceEnableOneWithHttpInfo(smsServiceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Returns sms services
     * Returns sms services
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public smsServiceQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.SmsServicePage> {
        return this.smsServiceQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing smsService
     * Get one existing smsService
     * @param smsServiceId The smsService identifier
     */
    public smsServiceReadOne(smsServiceId: string, extraHttpRequestParams?: any): Observable<models.SmsService> {
        return this.smsServiceReadOneWithHttpInfo(smsServiceId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing smsService
     * update existing smsService
     * @param smsServiceId The user identifier
     * @param updatedSmsService updated smsService
     */
    public smsServiceUpdateOne(smsServiceId: string, updatedSmsService: models.SmsServiceUpdate, extraHttpRequestParams?: any): Observable<models.SmsService> {
        return this.smsServiceUpdateOneWithHttpInfo(smsServiceId, updatedSmsService, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * delete existing user
     * delete existing user
     * @param userId The user identifier or me
     */
    public usersDeleteOne(userId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.usersDeleteOneWithHttpInfo(userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Query existing users
     * Query existing users
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;john doe\&quot;, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1, \&quot;name\&quot; : 1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public usersQuery(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<models.UserPage> {
        return this.usersQueryWithHttpInfo(pageSize, pageNumber, filter, sort, select, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get one existing users
     * Get one existing users
     * @param userId The user identifier
     */
    public usersReadOne(userId: string, extraHttpRequestParams?: any): Observable<models.User> {
        return this.usersReadOneWithHttpInfo(userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * update existing user
     * update existing user
     * @param userId The user identifier
     * @param updatedUser updated user
     */
    public usersUpdateOne(userId: string, updatedUser: models.UserUpdate, extraHttpRequestParams?: any): Observable<models.User> {
        return this.usersUpdateOneWithHttpInfo(userId, updatedUser, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * Execute a REST request to a deployed REST API
     * Execute a REST request to a deployed REST API
     * @param stage The stage identifier
     * @param resource The resource path
     */
    public _deleteWithHttpInfo(stage: string, resource: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/rest/${stage}/${resource}'
                    .replace('${' + 'stage' + '}', String(stage))
                    .replace('${' + 'resource' + '}', String(resource));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'stage' is not null or undefined
        if (stage === null || stage === undefined) {
            throw new Error('Required parameter stage was null or undefined when calling _delete.');
        }
        // verify required parameter 'resource' is not null or undefined
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling _delete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create multiple new actions
     * Create multiple new actions
     * @param actions Multiple actions
     */
    public actionsCreateManyWithHttpInfo(actions?: models.NewActionArray, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/actions/bulk';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: actions == null ? '' : JSON.stringify(actions), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new action
     * Create new action
     * @param action Your new action
     */
    public actionsCreateOneWithHttpInfo(action?: models.NewAction, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/actions';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: action == null ? '' : JSON.stringify(action), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing actions
     * Bulk delete existing actions
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public actionsDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/actions';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling actionsDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing action
     * delete existing action
     * @param actionId The action identifier
     */
    public actionsDeleteOneWithHttpInfo(actionId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/actions/${actionId}'
                    .replace('${' + 'actionId' + '}', String(actionId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'actionId' is not null or undefined
        if (actionId === null || actionId === undefined) {
            throw new Error('Required parameter actionId was null or undefined when calling actionsDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Execute action.
     * Execute action. If the action code throws errors, they are caught and information is provided in the payload with status code 200.
     * @param actionId The action identifier
     * @param payload Execution payload
     */
    public actionsExecuteOneWithHttpInfo(actionId: string, payload?: models.ActionExecutionRequestPayload, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/actions/${actionId}/exec'
                    .replace('${' + 'actionId' + '}', String(actionId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'actionId' is not null or undefined
        if (actionId === null || actionId === undefined) {
            throw new Error('Required parameter actionId was null or undefined when calling actionsExecuteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: payload == null ? '' : JSON.stringify(payload), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns actions
     * Returns actions
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public actionsQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/actions';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing action
     * Get one existing action
     * @param actionId The action identifier
     */
    public actionsReadOneWithHttpInfo(actionId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/actions/${actionId}'
                    .replace('${' + 'actionId' + '}', String(actionId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'actionId' is not null or undefined
        if (actionId === null || actionId === undefined) {
            throw new Error('Required parameter actionId was null or undefined when calling actionsReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk update existing actions
     * Bulk update existing actions
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param actionBulkUpdate Use filter to find the actions and do a bulk update
     */
    public actionsUpdateManyWithHttpInfo(filter: string, actionBulkUpdate: models.ActionBulkUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/actions';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling actionsUpdateMany.');
        }
        // verify required parameter 'actionBulkUpdate' is not null or undefined
        if (actionBulkUpdate === null || actionBulkUpdate === undefined) {
            throw new Error('Required parameter actionBulkUpdate was null or undefined when calling actionsUpdateMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: actionBulkUpdate == null ? '' : JSON.stringify(actionBulkUpdate), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing action
     * update existing action
     * @param actionId The user identifier
     * @param updatedAction updated action
     */
    public actionsUpdateOneWithHttpInfo(actionId: string, updatedAction: models.ActionUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/actions/${actionId}'
                    .replace('${' + 'actionId' + '}', String(actionId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'actionId' is not null or undefined
        if (actionId === null || actionId === undefined) {
            throw new Error('Required parameter actionId was null or undefined when calling actionsUpdateOne.');
        }
        // verify required parameter 'updatedAction' is not null or undefined
        if (updatedAction === null || updatedAction === undefined) {
            throw new Error('Required parameter updatedAction was null or undefined when calling actionsUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedAction == null ? '' : JSON.stringify(updatedAction), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * change user password globally
     * change user password globally
     * @param userId The user identifier or me
     * @param adminChangePasswordRequest change password request
     */
    public changeUserPasswordAllOrganizationsWithHttpInfo(userId: string, adminChangePasswordRequest: models.AdminChangePasswordRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/users/${userId}/changepassword'
                    .replace('${' + 'userId' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling changeUserPasswordAllOrganizations.');
        }
        // verify required parameter 'adminChangePasswordRequest' is not null or undefined
        if (adminChangePasswordRequest === null || adminChangePasswordRequest === undefined) {
            throw new Error('Required parameter adminChangePasswordRequest was null or undefined when calling changeUserPasswordAllOrganizations.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: adminChangePasswordRequest == null ? '' : JSON.stringify(adminChangePasswordRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * change user password for one organization
     * change user password for one organization
     * @param userId The user identifier or me
     * @param organizationId The user identifier or me
     * @param adminChangePasswordRequest change password request
     */
    public changeUserPasswordByOrganizationWithHttpInfo(userId: string, organizationId: string, adminChangePasswordRequest: models.AdminChangePasswordRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/users/${userId}/organization/${organizationId}/changepassword'
                    .replace('${' + 'userId' + '}', String(userId))
                    .replace('${' + 'organizationId' + '}', String(organizationId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling changeUserPasswordByOrganization.');
        }
        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling changeUserPasswordByOrganization.');
        }
        // verify required parameter 'adminChangePasswordRequest' is not null or undefined
        if (adminChangePasswordRequest === null || adminChangePasswordRequest === undefined) {
            throw new Error('Required parameter adminChangePasswordRequest was null or undefined when calling changeUserPasswordByOrganization.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: adminChangePasswordRequest == null ? '' : JSON.stringify(adminChangePasswordRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create multiple new clients
     * Create multiple new clients
     * @param clients Multiple clients
     */
    public clientsCreateManyWithHttpInfo(clients?: models.NewClientArray, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/clients/bulk';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: clients == null ? '' : JSON.stringify(clients), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new client
     * Create new client
     * @param client Your new client
     */
    public clientsCreateOneWithHttpInfo(client?: models.NewClient, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/clients';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: client == null ? '' : JSON.stringify(client), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing clients
     * Bulk delete existing clients
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public clientsDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/clients';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling clientsDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing client
     * delete existing client
     * @param clientId The client identifier
     */
    public clientsDeleteOneWithHttpInfo(clientId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/clients/${clientId}'
                    .replace('${' + 'clientId' + '}', String(clientId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling clientsDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns clients
     * Returns clients
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public clientsQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/clients';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing client
     * Get one existing client
     * @param clientId The client identifier
     */
    public clientsReadOneWithHttpInfo(clientId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/clients/${clientId}'
                    .replace('${' + 'clientId' + '}', String(clientId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling clientsReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk update existing clients
     * Bulk update existing clients
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param clientBulkUpdate Use filter to find the clients and do a bulk update
     */
    public clientsUpdateManyWithHttpInfo(filter: string, clientBulkUpdate: models.ClientBulkUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/clients';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling clientsUpdateMany.');
        }
        // verify required parameter 'clientBulkUpdate' is not null or undefined
        if (clientBulkUpdate === null || clientBulkUpdate === undefined) {
            throw new Error('Required parameter clientBulkUpdate was null or undefined when calling clientsUpdateMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: clientBulkUpdate == null ? '' : JSON.stringify(clientBulkUpdate), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing client
     * update existing client
     * @param clientId The user identifier
     * @param updatedClient updated client
     */
    public clientsUpdateOneWithHttpInfo(clientId: string, updatedClient: models.ClientUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/clients/${clientId}'
                    .replace('${' + 'clientId' + '}', String(clientId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling clientsUpdateOne.');
        }
        // verify required parameter 'updatedClient' is not null or undefined
        if (updatedClient === null || updatedClient === undefined) {
            throw new Error('Required parameter updatedClient was null or undefined when calling clientsUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedClient == null ? '' : JSON.stringify(updatedClient), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing consumers
     * Bulk delete existing consumers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public consumersDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/consumers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling consumersDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing consumer
     * delete existing consumer
     * @param consumerId The consumer identifier
     */
    public consumersDeleteOneWithHttpInfo(consumerId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/consumers/${consumerId}'
                    .replace('${' + 'consumerId' + '}', String(consumerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'consumerId' is not null or undefined
        if (consumerId === null || consumerId === undefined) {
            throw new Error('Required parameter consumerId was null or undefined when calling consumersDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns consumers
     * Returns consumers
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public consumersQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/consumers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing consumer
     * Get one existing consumer
     * @param consumerId The consumer identifier
     */
    public consumersReadOneWithHttpInfo(consumerId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/consumers/${consumerId}'
                    .replace('${' + 'consumerId' + '}', String(consumerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'consumerId' is not null or undefined
        if (consumerId === null || consumerId === undefined) {
            throw new Error('Required parameter consumerId was null or undefined when calling consumersReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk update existing consumers
     * Bulk update existing consumers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param consumerBulkUpdate Use filter to find the consumers and do a bulk update
     */
    public consumersUpdateManyWithHttpInfo(filter: string, consumerBulkUpdate: models.ConsumerBulkUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/consumers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling consumersUpdateMany.');
        }
        // verify required parameter 'consumerBulkUpdate' is not null or undefined
        if (consumerBulkUpdate === null || consumerBulkUpdate === undefined) {
            throw new Error('Required parameter consumerBulkUpdate was null or undefined when calling consumersUpdateMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: consumerBulkUpdate == null ? '' : JSON.stringify(consumerBulkUpdate), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing consumer
     * update existing consumer
     * @param consumerId The user identifier
     * @param updatedConsumer updated consumer
     */
    public consumersUpdateOneWithHttpInfo(consumerId: string, updatedConsumer: models.ConsumerUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/consumers/${consumerId}'
                    .replace('${' + 'consumerId' + '}', String(consumerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'consumerId' is not null or undefined
        if (consumerId === null || consumerId === undefined) {
            throw new Error('Required parameter consumerId was null or undefined when calling consumersUpdateOne.');
        }
        // verify required parameter 'updatedConsumer' is not null or undefined
        if (updatedConsumer === null || updatedConsumer === undefined) {
            throw new Error('Required parameter updatedConsumer was null or undefined when calling consumersUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedConsumer == null ? '' : JSON.stringify(updatedConsumer), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing devices
     * Bulk delete existing devices
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public devicesDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/devices';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling devicesDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing device
     * delete existing device
     * @param deviceId The device identifier
     */
    public devicesDeleteOneWithHttpInfo(deviceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/devices/${deviceId}'
                    .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns devices
     * Returns devices
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public devicesQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/devices';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing device
     * Get one existing device
     * @param deviceId The device identifier
     */
    public devicesReadOneWithHttpInfo(deviceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/devices/${deviceId}'
                    .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create multiple new directories
     * Create multiple new directories
     * @param directories Multiple directories
     */
    public directoriesCreateManyWithHttpInfo(directories?: models.NewDirectoryArray, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/directories/bulk';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: directories == null ? '' : JSON.stringify(directories), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new directory
     * Create new directory
     * @param directory Your new directory
     */
    public directoriesCreateOneWithHttpInfo(directory?: models.NewDirectory, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/directories';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: directory == null ? '' : JSON.stringify(directory), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing directories
     * Bulk delete existing directories
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public directoriesDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/directories';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling directoriesDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing directory
     * delete existing directory
     * @param directoryId The directory identifier
     */
    public directoriesDeleteOneWithHttpInfo(directoryId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/directories/${directoryId}'
                    .replace('${' + 'directoryId' + '}', String(directoryId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'directoryId' is not null or undefined
        if (directoryId === null || directoryId === undefined) {
            throw new Error('Required parameter directoryId was null or undefined when calling directoriesDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns directories
     * Returns directories
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public directoriesQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/directories';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing directory
     * Get one existing directory
     * @param directoryId The directory identifier
     */
    public directoriesReadOneWithHttpInfo(directoryId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/directories/${directoryId}'
                    .replace('${' + 'directoryId' + '}', String(directoryId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'directoryId' is not null or undefined
        if (directoryId === null || directoryId === undefined) {
            throw new Error('Required parameter directoryId was null or undefined when calling directoriesReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk update existing users
     * Bulk update existing users
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param directoryBulkUpdate Use filter to find the directories and do a bulk update
     */
    public directoriesUpdateManyWithHttpInfo(filter: string, directoryBulkUpdate: models.DirectoryBulkUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/directories';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling directoriesUpdateMany.');
        }
        // verify required parameter 'directoryBulkUpdate' is not null or undefined
        if (directoryBulkUpdate === null || directoryBulkUpdate === undefined) {
            throw new Error('Required parameter directoryBulkUpdate was null or undefined when calling directoriesUpdateMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: directoryBulkUpdate == null ? '' : JSON.stringify(directoryBulkUpdate), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing directory
     * update existing directory
     * @param directoryId The user identifier
     * @param updatedDirectory updated directory
     */
    public directoriesUpdateOneWithHttpInfo(directoryId: string, updatedDirectory: models.DirectoryUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/directories/${directoryId}'
                    .replace('${' + 'directoryId' + '}', String(directoryId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'directoryId' is not null or undefined
        if (directoryId === null || directoryId === undefined) {
            throw new Error('Required parameter directoryId was null or undefined when calling directoriesUpdateOne.');
        }
        // verify required parameter 'updatedDirectory' is not null or undefined
        if (updatedDirectory === null || updatedDirectory === undefined) {
            throw new Error('Required parameter updatedDirectory was null or undefined when calling directoriesUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedDirectory == null ? '' : JSON.stringify(updatedDirectory), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create multiple new endpoints
     * Create multiple new endpoints
     * @param endpoints Multiple endpoints
     */
    public endpointsCreateManyWithHttpInfo(endpoints?: models.NewEndpointArray, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/endpoints/bulk';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: endpoints == null ? '' : JSON.stringify(endpoints), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new endpoint
     * Create new endpoint
     * @param endpoint Your new endpoint
     */
    public endpointsCreateOneWithHttpInfo(endpoint?: models.NewEndpoint, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/endpoints';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: endpoint == null ? '' : JSON.stringify(endpoint), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing endpoints
     * Bulk delete existing endpoints
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public endpointsDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/endpoints';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling endpointsDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing endpoint
     * delete existing endpoint
     * @param endpointId The endpoint identifier
     */
    public endpointsDeleteOneWithHttpInfo(endpointId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/endpoints/${endpointId}'
                    .replace('${' + 'endpointId' + '}', String(endpointId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'endpointId' is not null or undefined
        if (endpointId === null || endpointId === undefined) {
            throw new Error('Required parameter endpointId was null or undefined when calling endpointsDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Deploy endpoint to stage
     * Deploy endpoint to stage
     * @param endpointId The endpoint identifier
     * @param stage The stage identifier
     */
    public endpointsDeployOneToStageWithHttpInfo(endpointId: string, stage: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/endpoints/${endpointId}/deploy/${stage}'
                    .replace('${' + 'endpointId' + '}', String(endpointId))
                    .replace('${' + 'stage' + '}', String(stage));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'endpointId' is not null or undefined
        if (endpointId === null || endpointId === undefined) {
            throw new Error('Required parameter endpointId was null or undefined when calling endpointsDeployOneToStage.');
        }
        // verify required parameter 'stage' is not null or undefined
        if (stage === null || stage === undefined) {
            throw new Error('Required parameter stage was null or undefined when calling endpointsDeployOneToStage.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns endpoints
     * Returns endpoints
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public endpointsQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/endpoints';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing endpoint
     * Get one existing endpoint
     * @param endpointId The endpoint identifier
     */
    public endpointsReadOneWithHttpInfo(endpointId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/endpoints/${endpointId}'
                    .replace('${' + 'endpointId' + '}', String(endpointId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'endpointId' is not null or undefined
        if (endpointId === null || endpointId === undefined) {
            throw new Error('Required parameter endpointId was null or undefined when calling endpointsReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk update existing users
     * Bulk update existing users
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param endpointBulkUpdate Use filter to find the endpoints and do a bulk update
     */
    public endpointsUpdateManyWithHttpInfo(filter: string, endpointBulkUpdate: models.EndpointBulkUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/endpoints';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling endpointsUpdateMany.');
        }
        // verify required parameter 'endpointBulkUpdate' is not null or undefined
        if (endpointBulkUpdate === null || endpointBulkUpdate === undefined) {
            throw new Error('Required parameter endpointBulkUpdate was null or undefined when calling endpointsUpdateMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: endpointBulkUpdate == null ? '' : JSON.stringify(endpointBulkUpdate), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing endpoint
     * update existing endpoint
     * @param endpointId The user identifier
     * @param updatedEndpoint updated endpoint
     */
    public endpointsUpdateOneWithHttpInfo(endpointId: string, updatedEndpoint: models.EndpointUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/endpoints/${endpointId}'
                    .replace('${' + 'endpointId' + '}', String(endpointId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'endpointId' is not null or undefined
        if (endpointId === null || endpointId === undefined) {
            throw new Error('Required parameter endpointId was null or undefined when calling endpointsUpdateOne.');
        }
        // verify required parameter 'updatedEndpoint' is not null or undefined
        if (updatedEndpoint === null || updatedEndpoint === undefined) {
            throw new Error('Required parameter updatedEndpoint was null or undefined when calling endpointsUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedEndpoint == null ? '' : JSON.stringify(updatedEndpoint), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Execute a REST request to a deployed REST API
     * Execute a REST request to a deployed REST API
     * @param stage The stage identifier
     * @param resource The resource path
     */
    public getWithHttpInfo(stage: string, resource: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/rest/${stage}/${resource}'
                    .replace('${' + 'stage' + '}', String(stage))
                    .replace('${' + 'resource' + '}', String(resource));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'stage' is not null or undefined
        if (stage === null || stage === undefined) {
            throw new Error('Required parameter stage was null or undefined when calling get.');
        }
        // verify required parameter 'resource' is not null or undefined
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling get.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing invites
     * Bulk delete existing invites
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public invitesDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/invites';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling invitesDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing invite
     * delete existing invite
     * @param inviteId The invite identifier
     */
    public invitesDeleteOneWithHttpInfo(inviteId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/invites/${inviteId}'
                    .replace('${' + 'inviteId' + '}', String(inviteId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'inviteId' is not null or undefined
        if (inviteId === null || inviteId === undefined) {
            throw new Error('Required parameter inviteId was null or undefined when calling invitesDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns invites
     * Returns invites
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public invitesQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/invites';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing invite
     * Get one existing invite
     * @param inviteId The invite identifier
     */
    public invitesReadOneWithHttpInfo(inviteId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/invites/${inviteId}'
                    .replace('${' + 'inviteId' + '}', String(inviteId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'inviteId' is not null or undefined
        if (inviteId === null || inviteId === undefined) {
            throw new Error('Required parameter inviteId was null or undefined when calling invitesReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new mailServer
     * Create new mailServer
     * @param mailServer Your new mailServer
     */
    public mailserversCreateOneWithHttpInfo(mailServer?: models.NewMailServer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/mailservers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: mailServer == null ? '' : JSON.stringify(mailServer), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing mailservers
     * Bulk delete existing mailservers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public mailserversDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/mailservers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling mailserversDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing mailServer
     * delete existing mailServer
     * @param mailServerId The mailServer identifier
     */
    public mailserversDeleteOneWithHttpInfo(mailServerId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/mailservers/${mailServerId}'
                    .replace('${' + 'mailServerId' + '}', String(mailServerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mailServerId' is not null or undefined
        if (mailServerId === null || mailServerId === undefined) {
            throw new Error('Required parameter mailServerId was null or undefined when calling mailserversDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Disable the push service.
     * Disable the push service.
     * @param mailServerId The mailServer identifier
     */
    public mailserversDisableOneWithHttpInfo(mailServerId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/mailservers/${mailServerId}/disable'
                    .replace('${' + 'mailServerId' + '}', String(mailServerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mailServerId' is not null or undefined
        if (mailServerId === null || mailServerId === undefined) {
            throw new Error('Required parameter mailServerId was null or undefined when calling mailserversDisableOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Enable the push service.
     * Enable the push service.
     * @param mailServerId The mailServer identifier
     */
    public mailserversEnableOneWithHttpInfo(mailServerId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/mailservers/${mailServerId}/enable'
                    .replace('${' + 'mailServerId' + '}', String(mailServerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mailServerId' is not null or undefined
        if (mailServerId === null || mailServerId === undefined) {
            throw new Error('Required parameter mailServerId was null or undefined when calling mailserversEnableOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns mail servers
     * Returns mail servers
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public mailserversQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/mailservers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing mailServer
     * Get one existing mailServer
     * @param mailServerId The mailServer identifier
     */
    public mailserversReadOneWithHttpInfo(mailServerId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/mailservers/${mailServerId}'
                    .replace('${' + 'mailServerId' + '}', String(mailServerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mailServerId' is not null or undefined
        if (mailServerId === null || mailServerId === undefined) {
            throw new Error('Required parameter mailServerId was null or undefined when calling mailserversReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing mailServer
     * update existing mailServer
     * @param mailServerId The user identifier
     * @param updatedMailServer updated mailServer
     */
    public mailserversUpdateOneWithHttpInfo(mailServerId: string, updatedMailServer: models.MailServerUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/mailservers/${mailServerId}'
                    .replace('${' + 'mailServerId' + '}', String(mailServerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'mailServerId' is not null or undefined
        if (mailServerId === null || mailServerId === undefined) {
            throw new Error('Required parameter mailServerId was null or undefined when calling mailserversUpdateOne.');
        }
        // verify required parameter 'updatedMailServer' is not null or undefined
        if (updatedMailServer === null || updatedMailServer === undefined) {
            throw new Error('Required parameter updatedMailServer was null or undefined when calling mailserversUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedMailServer == null ? '' : JSON.stringify(updatedMailServer), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create multiple new organizations
     * Create multiple new organizations
     * @param organizations Multiple organizations
     */
    public organizationsCreateManyWithHttpInfo(organizations?: models.NewOrganizationArray, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/organizations/bulk';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: organizations == null ? '' : JSON.stringify(organizations), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new organization
     * Create new organization
     * @param organization Your new organization
     */
    public organizationsCreateOneWithHttpInfo(organization?: models.NewOrganization, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/organizations';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: organization == null ? '' : JSON.stringify(organization), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing organizations
     * Bulk delete existing organizations
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public organizationsDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/organizations';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling organizationsDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing organization
     * delete existing organization
     * @param organizationId The organization identifier
     */
    public organizationsDeleteOneWithHttpInfo(organizationId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/organizations/${organizationId}'
                    .replace('${' + 'organizationId' + '}', String(organizationId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling organizationsDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns organizations
     * Returns organizations
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;isPublic\&quot;: \&quot;true\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     * @param _public Fixed filter for public organizations
     */
    public organizationsQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, _public?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/organizations';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        if (_public !== undefined) {
            queryParameters.set('public', <any>_public);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing organization
     * Get one existing organization
     * @param organizationId The organization identifier
     */
    public organizationsReadOneWithHttpInfo(organizationId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/organizations/${organizationId}'
                    .replace('${' + 'organizationId' + '}', String(organizationId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling organizationsReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk update existing organizations
     * Bulk update existing organizations
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param organizationBulkUpdate Use filter to find the organizations and do a bulk update
     */
    public organizationsUpdateManyWithHttpInfo(filter: string, organizationBulkUpdate: models.OrganizationBulkUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/organizations';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling organizationsUpdateMany.');
        }
        // verify required parameter 'organizationBulkUpdate' is not null or undefined
        if (organizationBulkUpdate === null || organizationBulkUpdate === undefined) {
            throw new Error('Required parameter organizationBulkUpdate was null or undefined when calling organizationsUpdateMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: organizationBulkUpdate == null ? '' : JSON.stringify(organizationBulkUpdate), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing organization
     * update existing organization
     * @param organizationId The user identifier
     * @param updatedOrganization updated organization
     */
    public organizationsUpdateOneWithHttpInfo(organizationId: string, updatedOrganization: models.OrganizationUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/organizations/${organizationId}'
                    .replace('${' + 'organizationId' + '}', String(organizationId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling organizationsUpdateOne.');
        }
        // verify required parameter 'updatedOrganization' is not null or undefined
        if (updatedOrganization === null || updatedOrganization === undefined) {
            throw new Error('Required parameter updatedOrganization was null or undefined when calling organizationsUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedOrganization == null ? '' : JSON.stringify(updatedOrganization), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Execute a REST request to a deployed REST API
     * Execute a REST request to a deployed REST API
     * @param stage The stage identifier
     * @param resource The resource path
     * @param payload Execution payload
     */
    public postWithHttpInfo(stage: string, resource: string, payload?: models.RestEndpointExecutionRequestPayload, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/rest/${stage}/${resource}'
                    .replace('${' + 'stage' + '}', String(stage))
                    .replace('${' + 'resource' + '}', String(resource));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'stage' is not null or undefined
        if (stage === null || stage === undefined) {
            throw new Error('Required parameter stage was null or undefined when calling post.');
        }
        // verify required parameter 'resource' is not null or undefined
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling post.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: payload == null ? '' : JSON.stringify(payload), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create multiple new providers
     * Create multiple new providers
     * @param providers Multiple providers
     */
    public providersCreateManyWithHttpInfo(providers?: models.NewProviderArray, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/providers/bulk';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: providers == null ? '' : JSON.stringify(providers), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new provider
     * Create new provider
     * @param provider Your new provider
     */
    public providersCreateOneWithHttpInfo(provider?: models.NewProvider, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/providers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: provider == null ? '' : JSON.stringify(provider), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing providers
     * Bulk delete existing providers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public providersDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/providers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling providersDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing provider
     * delete existing provider
     * @param providerId The provider identifier
     */
    public providersDeleteOneWithHttpInfo(providerId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/providers/${providerId}'
                    .replace('${' + 'providerId' + '}', String(providerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'providerId' is not null or undefined
        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling providersDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns providers
     * Returns providers
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public providersQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/providers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing provider
     * Get one existing provider
     * @param providerId The provider identifier
     */
    public providersReadOneWithHttpInfo(providerId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/providers/${providerId}'
                    .replace('${' + 'providerId' + '}', String(providerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'providerId' is not null or undefined
        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling providersReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk update existing providers
     * Bulk update existing providers
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param providerBulkUpdate Use filter to find the providers and do a bulk update
     */
    public providersUpdateManyWithHttpInfo(filter: string, providerBulkUpdate: models.ProviderBulkUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/providers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling providersUpdateMany.');
        }
        // verify required parameter 'providerBulkUpdate' is not null or undefined
        if (providerBulkUpdate === null || providerBulkUpdate === undefined) {
            throw new Error('Required parameter providerBulkUpdate was null or undefined when calling providersUpdateMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: providerBulkUpdate == null ? '' : JSON.stringify(providerBulkUpdate), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing provider
     * update existing provider
     * @param providerId The user identifier
     * @param updatedProvider updated provider
     */
    public providersUpdateOneWithHttpInfo(providerId: string, updatedProvider: models.ProviderUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/providers/${providerId}'
                    .replace('${' + 'providerId' + '}', String(providerId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'providerId' is not null or undefined
        if (providerId === null || providerId === undefined) {
            throw new Error('Required parameter providerId was null or undefined when calling providersUpdateOne.');
        }
        // verify required parameter 'updatedProvider' is not null or undefined
        if (updatedProvider === null || updatedProvider === undefined) {
            throw new Error('Required parameter updatedProvider was null or undefined when calling providersUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedProvider == null ? '' : JSON.stringify(updatedProvider), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new pushService
     * Create new pushService
     * @param pushService Your new pushService
     */
    public pushservicesCreateOneWithHttpInfo(pushService?: models.NewPushService, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/pushservices';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: pushService == null ? '' : JSON.stringify(pushService), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing pushservices
     * Bulk delete existing pushservices
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public pushservicesDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/pushservices';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling pushservicesDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing pushService
     * delete existing pushService
     * @param pushServiceId The pushService identifier
     */
    public pushservicesDeleteOneWithHttpInfo(pushServiceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/pushservices/${pushServiceId}'
                    .replace('${' + 'pushServiceId' + '}', String(pushServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'pushServiceId' is not null or undefined
        if (pushServiceId === null || pushServiceId === undefined) {
            throw new Error('Required parameter pushServiceId was null or undefined when calling pushservicesDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Disable the push service.
     * Disable the push service.
     * @param pushServiceId The pushService identifier
     */
    public pushservicesDisableOneWithHttpInfo(pushServiceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/pushservices/${pushServiceId}/disable'
                    .replace('${' + 'pushServiceId' + '}', String(pushServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'pushServiceId' is not null or undefined
        if (pushServiceId === null || pushServiceId === undefined) {
            throw new Error('Required parameter pushServiceId was null or undefined when calling pushservicesDisableOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Enable the push service.
     * Enable the push service.
     * @param pushServiceId The pushService identifier
     */
    public pushservicesEnableOneWithHttpInfo(pushServiceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/pushservices/${pushServiceId}/enable'
                    .replace('${' + 'pushServiceId' + '}', String(pushServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'pushServiceId' is not null or undefined
        if (pushServiceId === null || pushServiceId === undefined) {
            throw new Error('Required parameter pushServiceId was null or undefined when calling pushservicesEnableOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns pushservices
     * Returns pushservices
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public pushservicesQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/pushservices';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing pushService
     * Get one existing pushService
     * @param pushServiceId The pushService identifier
     */
    public pushservicesReadOneWithHttpInfo(pushServiceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/pushservices/${pushServiceId}'
                    .replace('${' + 'pushServiceId' + '}', String(pushServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'pushServiceId' is not null or undefined
        if (pushServiceId === null || pushServiceId === undefined) {
            throw new Error('Required parameter pushServiceId was null or undefined when calling pushservicesReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing pushService
     * update existing pushService
     * @param pushServiceId The user identifier
     * @param updatedPushService updated pushService
     */
    public pushservicesUpdateOneWithHttpInfo(pushServiceId: string, updatedPushService: models.PushServiceUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/pushservices/${pushServiceId}'
                    .replace('${' + 'pushServiceId' + '}', String(pushServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'pushServiceId' is not null or undefined
        if (pushServiceId === null || pushServiceId === undefined) {
            throw new Error('Required parameter pushServiceId was null or undefined when calling pushservicesUpdateOne.');
        }
        // verify required parameter 'updatedPushService' is not null or undefined
        if (updatedPushService === null || updatedPushService === undefined) {
            throw new Error('Required parameter updatedPushService was null or undefined when calling pushservicesUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedPushService == null ? '' : JSON.stringify(updatedPushService), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Execute a REST request to a deployed REST API
     * Execute a REST request to a deployed REST API
     * @param stage The stage identifier
     * @param resource The resource path
     * @param payload Execution payload
     */
    public putWithHttpInfo(stage: string, resource: string, payload?: models.RestEndpointExecutionRequestPayload, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/rest/${stage}/${resource}'
                    .replace('${' + 'stage' + '}', String(stage))
                    .replace('${' + 'resource' + '}', String(resource));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'stage' is not null or undefined
        if (stage === null || stage === undefined) {
            throw new Error('Required parameter stage was null or undefined when calling put.');
        }
        // verify required parameter 'resource' is not null or undefined
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling put.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: payload == null ? '' : JSON.stringify(payload), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create multiple new roles
     * Create multiple new roles
     * @param roles Multiple roles
     */
    public rolesCreateManyWithHttpInfo(roles?: models.NewRoleArray, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/roles/bulk';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: roles == null ? '' : JSON.stringify(roles), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new role
     * Create new role
     * @param role Your new role
     */
    public rolesCreateOneWithHttpInfo(role?: models.NewRole, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/roles';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: role == null ? '' : JSON.stringify(role), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing roles
     * Bulk delete existing roles
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public rolesDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/roles';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling rolesDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing role
     * delete existing role
     * @param roleId The role identifier
     */
    public rolesDeleteOneWithHttpInfo(roleId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/roles/${roleId}'
                    .replace('${' + 'roleId' + '}', String(roleId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling rolesDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns roles
     * Returns roles
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public rolesQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/roles';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing role
     * Get one existing role
     * @param roleId The role identifier
     */
    public rolesReadOneWithHttpInfo(roleId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/roles/${roleId}'
                    .replace('${' + 'roleId' + '}', String(roleId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling rolesReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk update existing roles
     * Bulk update existing roles
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;xyz\&quot;}
     * @param roleBulkUpdate Use filter to find the roles and do a bulk update
     */
    public rolesUpdateManyWithHttpInfo(filter: string, roleBulkUpdate: models.RoleBulkUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/roles';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling rolesUpdateMany.');
        }
        // verify required parameter 'roleBulkUpdate' is not null or undefined
        if (roleBulkUpdate === null || roleBulkUpdate === undefined) {
            throw new Error('Required parameter roleBulkUpdate was null or undefined when calling rolesUpdateMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: roleBulkUpdate == null ? '' : JSON.stringify(roleBulkUpdate), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing role
     * update existing role
     * @param roleId The user identifier
     * @param updatedRole updated role
     */
    public rolesUpdateOneWithHttpInfo(roleId: string, updatedRole: models.RoleUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/roles/${roleId}'
                    .replace('${' + 'roleId' + '}', String(roleId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling rolesUpdateOne.');
        }
        // verify required parameter 'updatedRole' is not null or undefined
        if (updatedRole === null || updatedRole === undefined) {
            throw new Error('Required parameter updatedRole was null or undefined when calling rolesUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedRole == null ? '' : JSON.stringify(updatedRole), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create new smsService
     * Create new smsService
     * @param smsService Your new smsService
     */
    public smsServiceCreateOneWithHttpInfo(smsService?: models.NewSmsService, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/sms';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: smsService == null ? '' : JSON.stringify(smsService), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk delete existing sms
     * Bulk delete existing sms
     * @param filter Sequelize filter object like {\&quot;name\&quot;: { \&quot;$like\&quot; : \&quot;app%\&quot;}, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     */
    public smsServiceDeleteManyWithHttpInfo(filter: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/sms';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling smsServiceDeleteMany.');
        }
        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing smsService
     * delete existing smsService
     * @param smsServiceId The smsService identifier
     */
    public smsServiceDeleteOneWithHttpInfo(smsServiceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/sms/${smsServiceId}'
                    .replace('${' + 'smsServiceId' + '}', String(smsServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'smsServiceId' is not null or undefined
        if (smsServiceId === null || smsServiceId === undefined) {
            throw new Error('Required parameter smsServiceId was null or undefined when calling smsServiceDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Disable the sms service.
     * Disable the sms service.
     * @param smsServiceId The smsService identifier
     */
    public smsServiceDisableOneWithHttpInfo(smsServiceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/sms/${smsServiceId}/disable'
                    .replace('${' + 'smsServiceId' + '}', String(smsServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'smsServiceId' is not null or undefined
        if (smsServiceId === null || smsServiceId === undefined) {
            throw new Error('Required parameter smsServiceId was null or undefined when calling smsServiceDisableOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Enable the sms service.
     * Enable the sms service.
     * @param smsServiceId The smsService identifier
     */
    public smsServiceEnableOneWithHttpInfo(smsServiceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/sms/${smsServiceId}/enable'
                    .replace('${' + 'smsServiceId' + '}', String(smsServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'smsServiceId' is not null or undefined
        if (smsServiceId === null || smsServiceId === undefined) {
            throw new Error('Required parameter smsServiceId was null or undefined when calling smsServiceEnableOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Returns sms services
     * Returns sms services
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;sbcloud\&quot;}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public smsServiceQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/sms';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing smsService
     * Get one existing smsService
     * @param smsServiceId The smsService identifier
     */
    public smsServiceReadOneWithHttpInfo(smsServiceId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/sms/${smsServiceId}'
                    .replace('${' + 'smsServiceId' + '}', String(smsServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'smsServiceId' is not null or undefined
        if (smsServiceId === null || smsServiceId === undefined) {
            throw new Error('Required parameter smsServiceId was null or undefined when calling smsServiceReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing smsService
     * update existing smsService
     * @param smsServiceId The user identifier
     * @param updatedSmsService updated smsService
     */
    public smsServiceUpdateOneWithHttpInfo(smsServiceId: string, updatedSmsService: models.SmsServiceUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/sms/${smsServiceId}'
                    .replace('${' + 'smsServiceId' + '}', String(smsServiceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'smsServiceId' is not null or undefined
        if (smsServiceId === null || smsServiceId === undefined) {
            throw new Error('Required parameter smsServiceId was null or undefined when calling smsServiceUpdateOne.');
        }
        // verify required parameter 'updatedSmsService' is not null or undefined
        if (updatedSmsService === null || updatedSmsService === undefined) {
            throw new Error('Required parameter updatedSmsService was null or undefined when calling smsServiceUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedSmsService == null ? '' : JSON.stringify(updatedSmsService), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete existing user
     * delete existing user
     * @param userId The user identifier or me
     */
    public usersDeleteOneWithHttpInfo(userId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/users/${userId}'
                    .replace('${' + 'userId' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersDeleteOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Query existing users
     * Query existing users
     * @param pageSize Items per page
     * @param pageNumber The page index (starting from 1)
     * @param filter Sequelize filter object like {\&quot;name\&quot;: \&quot;john doe\&quot;, \&quot;customData\&quot;: { \&quot;$contains\&quot;: {\&quot;key2\&quot; : \&quot;val2\&quot;}}}
     * @param sort Sort object (1&#x3D;ascending, -1&#x3D;descending) like {\&quot;createdAt\&quot;: -1, \&quot;name\&quot; : 1 }
     * @param select Select object (1&#x3D;include, -1&#x3D;exclude) like {\&quot;Id\&quot;: 1, \&quot;name\&quot;: 1 }
     */
    public usersQueryWithHttpInfo(pageSize?: number, pageNumber?: number, filter?: string, sort?: string, select?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/users';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (pageSize !== undefined) {
            queryParameters.set('pageSize', <any>pageSize);
        }

        if (pageNumber !== undefined) {
            queryParameters.set('pageNumber', <any>pageNumber);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (select !== undefined) {
            queryParameters.set('select', <any>select);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get one existing users
     * Get one existing users
     * @param userId The user identifier
     */
    public usersReadOneWithHttpInfo(userId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/users/${userId}'
                    .replace('${' + 'userId' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersReadOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update existing user
     * update existing user
     * @param userId The user identifier
     * @param updatedUser updated user
     */
    public usersUpdateOneWithHttpInfo(userId: string, updatedUser: models.UserUpdate, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.configuration.basePath + '/users/${userId}'
                    .replace('${' + 'userId' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersUpdateOne.');
        }
        // verify required parameter 'updatedUser' is not null or undefined
        if (updatedUser === null || updatedUser === undefined) {
            throw new Error('Required parameter updatedUser was null or undefined when calling usersUpdateOne.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ConsumerSecurity) required
        if (this.configuration.apiKey) {
            headers.set('Authorization', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: updatedUser == null ? '' : JSON.stringify(updatedUser), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
